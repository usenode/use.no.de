
<~inherit "/micro/base.spv" />

<~init>
    this.subNavSelected = 'getting-started';
</~init>

<h1>Routes</h1>

<~method pageTitle>Micro Routes</~method>
<!-- TODO whaa?
<p>All routes are relative to a root URL that is expressed outside of the webapp (Micro.js webapps can easily be moved to a diffrent URL space).</p>
-->

<p>
    A route is a URL path you want your application to respond to.
    You can have as many routes as you want.
</p>

<p>
    A route can be as simple as:
</p>

<pre><code class="unpretty">/users/tom
</code></pre>

<p>
    A Micro application responds to a route using a handler, such as <code>get</code>.
</p>

<pre><code>get('/users/tom', function (request, response, args) {
    response.ok('text/html');
    return 'hello, tom';
});
</code></pre>

<p>
    The application will now respond to <a href="http://localhost:8080/users/tom">http://localhost:8080/users/tom</a>.
</p>

<h2>Named Parameters</h2>

<p>
    Routes can include placeholders called named parameters.
</p>

<p>
    This allows your application to respond to routes based on their structure rather than just their content.
    A named parameter starts with a colon <code>:</code>.
</p>

<pre><code>get('/users/:name', function (request, response, args) {
    response.ok('text/html');
    return 'hello, ' + args.name;
});
</code></pre>

<p>
    The URL <a href="http://localhost:8080/users/tom">http://localhost:8080/users/tom</a> still works, however you can now also call <a href="http://localhost:8080/users/richard">http://localhost:8080/users/richard</a> too.
</p>

<p>
    Placeholders can be named with any characters, except a forward slash.
    You can override this, see <a href="#validating-named-and-postional-parameters">Validating Named and Postional Parameters</a> below.
</p>

<h2>Positional Parameters</h2>

<p>
    Alternatively to named parameters, you can create routes containing placeholders with an asterisk <code>*</code>.
</p>

<p>
    The matched values are then passed to your handler as parameters.
</p>

<pre><code>get('/users/*/*', function (request, response, firstname, surname) {
    response.ok('text/html');
    return 'hello, ' + firstname + ' ' + surname;
});
</code></pre>

<p>
    The route above would be called when you visit <a href="http://localhost:8080/users/tom/yandell">http://localhost:8080/users/tom/yandell</a>.
</p>

<p>
    You can't mix named parameters and positional parameters in the same route.
</p>

<h2 id="validating-named-and-postional-parameters">Validating Named and Positional Parameters</h2>

<p>
    In order to restrict the values that will be accepted by a route, a placeholder can be followed by a regular expression fragement contained in brackets.
</p>

<pre><code>get('/users/:name(\\w+)', function (request, response, args) {
    response.ok('text/html');
    return 'hello, ' + firstname + ' ' + surname;
});
</code></pre>

<p>
    This route will match <a href="http://localhost:8080/users/tom">http://localhost:8080/users/tom</a>, but won't match a placeholder containing non-alphanumeric characters such as <a href="http://localhost:8080/users/$-;">http://localhost:8080/users/$-;</a>.
</p>
<p>
    As the regular expression is specified as part of a string rather than as a regular expression literal, backslashes will have to be in pairs as they would for the parameter to a <code>new RegExp</code>.
</p>

<p>
    This works for both named and positional placeholders (e.g. <code>/hello/*(\\w+)</code>).
</p>

<h2>RegExp Routes</h2>

<p>If the first parameter to get, post, etc. is a regular expression, the corresponding action will be invoked when the regular expression matches the path in the http request. Any captures in the regular expression are passed as arguments to the action callback. For example:</p>

<pre><code>get(/^\/hello\/(\w+)$/, function (request, response, name) {
    response.ok('text/html');
    return 'hello, ' + name;
});
</code></pre>

<p>This behaves the same as for the previous examples.</p>

<h2>Function Routes</h2>

<p>If you've got really complicated requirements for routing, you can pass a function as the route. The function is passed the request path and its invocant (the value of "this" within the function) is the request. The function should return an containing zero or more arguments for the action callback if the route matches. For example:</p>

<pre><code>get(function (path) {
    if (path === '/foo' && this.queryString === '?a=1') {
        return ['bar'];
    }
}, function (request, response, baz) {
    // baz contains 'bar' here
});
</code></pre>

<p>Although this feature is supported, it isn't really recommended as it makes the code less readable/maintainable. The recommended practise is to use one of the other routes and put non-path based checks into the action callback, moving onto the next route by returning:</p>

<pre><code>get('/foo', function (request, response) {
    if (this.queryString !== '?a=1') {
        return;
    }
    // ...
})
</code></pre>